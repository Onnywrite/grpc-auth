// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.3
// source: auth.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthClient is the client API for Auth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Register
	//  registrates you in the whole SSO system and let you to sign up
	//  in any service
	// Takes:
	//  - at least login or email or phone
	//    (you can send login and email, or phone and email, or all together,
	//    but at least one optional field must be valid)
	// Returns:
	//  3 if arguments are not valid;
	//  6 if user with these credentials already exists;
	//  9 if user has unregistred and can recover its account via Recover;
	//  13 if an internal error occurred
	// TODO: write docs
	Register(ctx context.Context, in *InRequest, opts ...grpc.CallOption) (*IdTokens, error)
	// Returns:
	//  3 if arguments are not valid;
	//  5 if user not found;
	//  9 if user has already been signed up to the service (no need in recovery);
	//  13 if an internal error occurred
	Recover(ctx context.Context, in *InRequest, opts ...grpc.CallOption) (*IdTokens, error)
	// Login
	//  TODO
	// Takes:
	//  - likely to contain info about session: browser, os, ip
	// Returns:
	//  3 if arguments are not valid;
	//  5 if signup not found;
	//  6 if user has already been logged in on this devce in this browser (no
	//  need to log in);
	//  13 if an internal error occurred
	Login(ctx context.Context, in *InRequest, opts ...grpc.CallOption) (*IdTokens, error)
	// Signup
	//  links your registered (existing) account to an existing service by its
	//  id
	// Takes:
	//  - either login or email or phone, which identifies user's existing
	//  account
	//  - user_password of an existing user
	//  - service_id of an existing service
	// Returns:
	//  5 if user or service or both not found;
	//  6 if user has already been signed up to the service;
	//  9 if user has signed out and can recover their account via
	//  RecoverSignup rpc; 13 if an internal error occurred
	Signup(ctx context.Context, in *AppRequest, opts ...grpc.CallOption) (*AppTokens, error)
	// RecoverSignup
	//  recover your registered (existing) signup if it's been signed out
	// Takes:
	//  - either login or email or phone, which identifies user's account
	//  - user_password of an existing user
	//  - service_id of an existing service
	// Returns:
	//  3 if arguments are not valid;
	//  5 if user or service or both not found (not exist);
	//  9 if user has already been signed up to the service (no need in recovery);
	//  13 if an internal error occurred
	RecoverSignup(ctx context.Context, in *AppRequest, opts ...grpc.CallOption) (*AppTokens, error)
	Signin(ctx context.Context, in *AppRequest, opts ...grpc.CallOption) (*AppTokens, error)
	// Relogin
	//  sends new updated access token (if it's expired) and new refresh token
	// Returns:
	//  3 if refresh token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred;
	//  16 if refresh token has expired (need to ask user to log in again)
	Resignin(ctx context.Context, in *RefreshToken, opts ...grpc.CallOption) (*AppTokens, error)
	// Signout
	//  terminates current session, which is stored in refresh token
	// Returns:
	//  3 if refresh token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated
	Signout(ctx context.Context, in *RefreshToken, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Check
	//  checks if your access token still be valid and unexpired
	// Returns:
	//  3 if access token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred
	//  16 if access token is invalid or has expired (need to call Relogin rpc)
	Check(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Takes:
	//  - either login or email or phone, which identifies user's account
	//  - password of the account
	//  - refresh token (you must be logged in to clear terminated sessions)
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	ClearTerminatedSessions(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Signout
	//  unlinks account from the service;
	//  It's like delete your account for the service.
	//  You have a half of year to recover the signup before it will be deleted
	//  completely
	// Takes:
	//  - either login or email or phone, which identifies user's account
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	Unsign(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns:
	//  3 if either type or access token cannot be treated as a JWT (you've sent
	//  rubbish); 13 if an internal error occurred; 16 if access token has expired
	//  (need to call Relogin rpc)
	GetSessions(ctx context.Context, in *GetSessionsRequest, opts ...grpc.CallOption) (*Sessions, error)
	// Returns:
	//  3 if access token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred
	//  16 if access token is invalid or has expired (need to call Relogin rpc)
	GetProfile(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*UserProfile, error)
	// Returns:
	//  3 if any new data is invalid;
	//  13 if an internal error occurred
	//  16 if access token is invalid or has expired (need to call Relogin rpc)
	EditProfile(ctx context.Context, in *EditProfileRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	LogoutEverywhere(ctx context.Context, in *DangerousRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SignoutEverywhere
	//  unlinks your account from all services it's linked to
	// Returns:
	//  5 if user's credentials are invalid;
	//  13 if an internal error occurred
	// Notes:
	//  - this rpc is so dangerous
	SignoutEverywhere(ctx context.Context, in *DangerousRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Unregister
	//  opposite for Register.
	//  You have one year to recover the account before it will be deleted
	//  completely
	// Takes:
	//  - either login or email or phone, which identifies user's account
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	Unregister(ctx context.Context, in *DangerousRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthClient(cc grpc.ClientConnInterface) AuthClient {
	return &authClient{cc}
}

func (c *authClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Register(ctx context.Context, in *InRequest, opts ...grpc.CallOption) (*IdTokens, error) {
	out := new(IdTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Recover(ctx context.Context, in *InRequest, opts ...grpc.CallOption) (*IdTokens, error) {
	out := new(IdTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/Recover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Login(ctx context.Context, in *InRequest, opts ...grpc.CallOption) (*IdTokens, error) {
	out := new(IdTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Signup(ctx context.Context, in *AppRequest, opts ...grpc.CallOption) (*AppTokens, error) {
	out := new(AppTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/Signup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) RecoverSignup(ctx context.Context, in *AppRequest, opts ...grpc.CallOption) (*AppTokens, error) {
	out := new(AppTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/RecoverSignup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Signin(ctx context.Context, in *AppRequest, opts ...grpc.CallOption) (*AppTokens, error) {
	out := new(AppTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/Signin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Resignin(ctx context.Context, in *RefreshToken, opts ...grpc.CallOption) (*AppTokens, error) {
	out := new(AppTokens)
	err := c.cc.Invoke(ctx, "/auth.Auth/Resignin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Signout(ctx context.Context, in *RefreshToken, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/Signout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Check(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) ClearTerminatedSessions(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/ClearTerminatedSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Unsign(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/Unsign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) GetSessions(ctx context.Context, in *GetSessionsRequest, opts ...grpc.CallOption) (*Sessions, error) {
	out := new(Sessions)
	err := c.cc.Invoke(ctx, "/auth.Auth/GetSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) GetProfile(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*UserProfile, error) {
	out := new(UserProfile)
	err := c.cc.Invoke(ctx, "/auth.Auth/GetProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) EditProfile(ctx context.Context, in *EditProfileRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/EditProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) LogoutEverywhere(ctx context.Context, in *DangerousRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/LogoutEverywhere", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) SignoutEverywhere(ctx context.Context, in *DangerousRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/SignoutEverywhere", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Unregister(ctx context.Context, in *DangerousRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/auth.Auth/Unregister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServer is the server API for Auth service.
// All implementations must embed UnimplementedAuthServer
// for forward compatibility
type AuthServer interface {
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Register
	//  registrates you in the whole SSO system and let you to sign up
	//  in any service
	// Takes:
	//  - at least login or email or phone
	//    (you can send login and email, or phone and email, or all together,
	//    but at least one optional field must be valid)
	// Returns:
	//  3 if arguments are not valid;
	//  6 if user with these credentials already exists;
	//  9 if user has unregistred and can recover its account via Recover;
	//  13 if an internal error occurred
	// TODO: write docs
	Register(context.Context, *InRequest) (*IdTokens, error)
	// Returns:
	//  3 if arguments are not valid;
	//  5 if user not found;
	//  9 if user has already been signed up to the service (no need in recovery);
	//  13 if an internal error occurred
	Recover(context.Context, *InRequest) (*IdTokens, error)
	// Login
	//  TODO
	// Takes:
	//  - likely to contain info about session: browser, os, ip
	// Returns:
	//  3 if arguments are not valid;
	//  5 if signup not found;
	//  6 if user has already been logged in on this devce in this browser (no
	//  need to log in);
	//  13 if an internal error occurred
	Login(context.Context, *InRequest) (*IdTokens, error)
	// Signup
	//  links your registered (existing) account to an existing service by its
	//  id
	// Takes:
	//  - either login or email or phone, which identifies user's existing
	//  account
	//  - user_password of an existing user
	//  - service_id of an existing service
	// Returns:
	//  5 if user or service or both not found;
	//  6 if user has already been signed up to the service;
	//  9 if user has signed out and can recover their account via
	//  RecoverSignup rpc; 13 if an internal error occurred
	Signup(context.Context, *AppRequest) (*AppTokens, error)
	// RecoverSignup
	//  recover your registered (existing) signup if it's been signed out
	// Takes:
	//  - either login or email or phone, which identifies user's account
	//  - user_password of an existing user
	//  - service_id of an existing service
	// Returns:
	//  3 if arguments are not valid;
	//  5 if user or service or both not found (not exist);
	//  9 if user has already been signed up to the service (no need in recovery);
	//  13 if an internal error occurred
	RecoverSignup(context.Context, *AppRequest) (*AppTokens, error)
	Signin(context.Context, *AppRequest) (*AppTokens, error)
	// Relogin
	//  sends new updated access token (if it's expired) and new refresh token
	// Returns:
	//  3 if refresh token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred;
	//  16 if refresh token has expired (need to ask user to log in again)
	Resignin(context.Context, *RefreshToken) (*AppTokens, error)
	// Signout
	//  terminates current session, which is stored in refresh token
	// Returns:
	//  3 if refresh token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated
	Signout(context.Context, *RefreshToken) (*emptypb.Empty, error)
	// Check
	//  checks if your access token still be valid and unexpired
	// Returns:
	//  3 if access token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred
	//  16 if access token is invalid or has expired (need to call Relogin rpc)
	Check(context.Context, *AccessToken) (*emptypb.Empty, error)
	// Takes:
	//  - either login or email or phone, which identifies user's account
	//  - password of the account
	//  - refresh token (you must be logged in to clear terminated sessions)
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	ClearTerminatedSessions(context.Context, *AccessToken) (*emptypb.Empty, error)
	// Signout
	//  unlinks account from the service;
	//  It's like delete your account for the service.
	//  You have a half of year to recover the signup before it will be deleted
	//  completely
	// Takes:
	//  - either login or email or phone, which identifies user's account
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	Unsign(context.Context, *AccessToken) (*emptypb.Empty, error)
	// Returns:
	//  3 if either type or access token cannot be treated as a JWT (you've sent
	//  rubbish); 13 if an internal error occurred; 16 if access token has expired
	//  (need to call Relogin rpc)
	GetSessions(context.Context, *GetSessionsRequest) (*Sessions, error)
	// Returns:
	//  3 if access token cannot be treated as a JWT (you've sent rubbish);
	//  13 if an internal error occurred
	//  16 if access token is invalid or has expired (need to call Relogin rpc)
	GetProfile(context.Context, *AccessToken) (*UserProfile, error)
	// Returns:
	//  3 if any new data is invalid;
	//  13 if an internal error occurred
	//  16 if access token is invalid or has expired (need to call Relogin rpc)
	EditProfile(context.Context, *EditProfileRequest) (*emptypb.Empty, error)
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	LogoutEverywhere(context.Context, *DangerousRequest) (*emptypb.Empty, error)
	// SignoutEverywhere
	//  unlinks your account from all services it's linked to
	// Returns:
	//  5 if user's credentials are invalid;
	//  13 if an internal error occurred
	// Notes:
	//  - this rpc is so dangerous
	SignoutEverywhere(context.Context, *DangerousRequest) (*emptypb.Empty, error)
	// Unregister
	//  opposite for Register.
	//  You have one year to recover the account before it will be deleted
	//  completely
	// Takes:
	//  - either login or email or phone, which identifies user's account
	// Returns:
	//  3 if refresh token has invalid signature;
	//  5 if user's credentials are invalid;
	//  7 if user in credentials and user opened the session mismatch
	//    (client probably has entered wrong password or
	//    forgot which account is currently in use);
	//  13 if an internal error occurred;
	//  16 if refresh token has either expired or session has already been
	//  terminated (check note 2)
	// Notes:
	//  - this rpc is dangerous
	//  - SSO will terminate ALL currently active sessions if 16 is returned
	//    (you'll have to log in again from all devices);
	//    To avoid this problem, get rid of the refresh token completely after
	//    you've logged out
	Unregister(context.Context, *DangerousRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAuthServer()
}

// UnimplementedAuthServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServer struct {
}

func (UnimplementedAuthServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedAuthServer) Register(context.Context, *InRequest) (*IdTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAuthServer) Recover(context.Context, *InRequest) (*IdTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recover not implemented")
}
func (UnimplementedAuthServer) Login(context.Context, *InRequest) (*IdTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServer) Signup(context.Context, *AppRequest) (*AppTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Signup not implemented")
}
func (UnimplementedAuthServer) RecoverSignup(context.Context, *AppRequest) (*AppTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverSignup not implemented")
}
func (UnimplementedAuthServer) Signin(context.Context, *AppRequest) (*AppTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Signin not implemented")
}
func (UnimplementedAuthServer) Resignin(context.Context, *RefreshToken) (*AppTokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resignin not implemented")
}
func (UnimplementedAuthServer) Signout(context.Context, *RefreshToken) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Signout not implemented")
}
func (UnimplementedAuthServer) Check(context.Context, *AccessToken) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedAuthServer) ClearTerminatedSessions(context.Context, *AccessToken) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearTerminatedSessions not implemented")
}
func (UnimplementedAuthServer) Unsign(context.Context, *AccessToken) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsign not implemented")
}
func (UnimplementedAuthServer) GetSessions(context.Context, *GetSessionsRequest) (*Sessions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessions not implemented")
}
func (UnimplementedAuthServer) GetProfile(context.Context, *AccessToken) (*UserProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfile not implemented")
}
func (UnimplementedAuthServer) EditProfile(context.Context, *EditProfileRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditProfile not implemented")
}
func (UnimplementedAuthServer) LogoutEverywhere(context.Context, *DangerousRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogoutEverywhere not implemented")
}
func (UnimplementedAuthServer) SignoutEverywhere(context.Context, *DangerousRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignoutEverywhere not implemented")
}
func (UnimplementedAuthServer) Unregister(context.Context, *DangerousRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unregister not implemented")
}
func (UnimplementedAuthServer) mustEmbedUnimplementedAuthServer() {}

// UnsafeAuthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServer will
// result in compilation errors.
type UnsafeAuthServer interface {
	mustEmbedUnimplementedAuthServer()
}

func RegisterAuthServer(s grpc.ServiceRegistrar, srv AuthServer) {
	s.RegisterService(&Auth_ServiceDesc, srv)
}

func _Auth_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Register(ctx, req.(*InRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Recover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Recover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Recover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Recover(ctx, req.(*InRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Login(ctx, req.(*InRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Signup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Signup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Signup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Signup(ctx, req.(*AppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_RecoverSignup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).RecoverSignup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/RecoverSignup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).RecoverSignup(ctx, req.(*AppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Signin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Signin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Signin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Signin(ctx, req.(*AppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Resignin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Resignin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Resignin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Resignin(ctx, req.(*RefreshToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Signout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Signout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Signout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Signout(ctx, req.(*RefreshToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Check(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_ClearTerminatedSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).ClearTerminatedSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/ClearTerminatedSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).ClearTerminatedSessions(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Unsign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Unsign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Unsign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Unsign(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_GetSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).GetSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/GetSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).GetSessions(ctx, req.(*GetSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/GetProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).GetProfile(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_EditProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).EditProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/EditProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).EditProfile(ctx, req.(*EditProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_LogoutEverywhere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DangerousRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).LogoutEverywhere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/LogoutEverywhere",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).LogoutEverywhere(ctx, req.(*DangerousRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_SignoutEverywhere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DangerousRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).SignoutEverywhere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/SignoutEverywhere",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).SignoutEverywhere(ctx, req.(*DangerousRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Unregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DangerousRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Unregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.Auth/Unregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Unregister(ctx, req.(*DangerousRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Auth_ServiceDesc is the grpc.ServiceDesc for Auth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auth_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Auth_Ping_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Auth_Register_Handler,
		},
		{
			MethodName: "Recover",
			Handler:    _Auth_Recover_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Auth_Login_Handler,
		},
		{
			MethodName: "Signup",
			Handler:    _Auth_Signup_Handler,
		},
		{
			MethodName: "RecoverSignup",
			Handler:    _Auth_RecoverSignup_Handler,
		},
		{
			MethodName: "Signin",
			Handler:    _Auth_Signin_Handler,
		},
		{
			MethodName: "Resignin",
			Handler:    _Auth_Resignin_Handler,
		},
		{
			MethodName: "Signout",
			Handler:    _Auth_Signout_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _Auth_Check_Handler,
		},
		{
			MethodName: "ClearTerminatedSessions",
			Handler:    _Auth_ClearTerminatedSessions_Handler,
		},
		{
			MethodName: "Unsign",
			Handler:    _Auth_Unsign_Handler,
		},
		{
			MethodName: "GetSessions",
			Handler:    _Auth_GetSessions_Handler,
		},
		{
			MethodName: "GetProfile",
			Handler:    _Auth_GetProfile_Handler,
		},
		{
			MethodName: "EditProfile",
			Handler:    _Auth_EditProfile_Handler,
		},
		{
			MethodName: "LogoutEverywhere",
			Handler:    _Auth_LogoutEverywhere_Handler,
		},
		{
			MethodName: "SignoutEverywhere",
			Handler:    _Auth_SignoutEverywhere_Handler,
		},
		{
			MethodName: "Unregister",
			Handler:    _Auth_Unregister_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}
