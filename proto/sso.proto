syntax = "proto3";

package auth;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

option go_package = "onnywrite.sso.v1;gen";
option csharp_namespace = "Onnywrite.SSO.Auth";

service Auth {
  // Ping
  //  makes sure gRPC server accepts connections
  // Returns:
  //  0 if it works;
  //  any code otherwise
  rpc Ping(google.protobuf.Empty) returns (google.protobuf.Empty);

  // Most usable RPCs

  // Register
  //  registrates you in the whole SSO system and let you to sign up
  //  in any service
  // Takes:
  //  - at least login or email or phone
  //    (you can send login and email, or phone and email, or all together,
  //    but at least one optional field must be valid)
  //  - password of an existing user
  // Returns:
  //  0 if you've successfully registrated;
  //  3 if arguments are not valid;
  //  6 if user with these credentials already exists;
  //  13 if an internal error occurred
  rpc Register(UserCredentials) returns (google.protobuf.Empty);

  // Signup
  //  links your registered (existing) account to an existing service by its id
  // Takes:
  //  - at least user_login or user_email or user_phone
  //    (you can send user_login and user_email, or user_phone and user_email, or all together,
  //    but at least one optional field must be valid)
  //  - user_password of an existing user
  //  - service_id of an existing service
  // Returns:
  //  0 if you've successfully signed up to the service;
  //  3 if arguments are not valid;
  //  5 if user or service or both not found (not exist);
  //  6 if user has already been signed up to the service;
  //  13 if an internal error occurred
  rpc Signup(SignupRequest) returns (google.protobuf.Empty);

  // Login
  //  opens a session for your existing signup (pair user and service) for
  //  specific browser and device (ip and os)
  // Takes:
  //  - at least user_login or user_email or user_phone
  //    (you can send user_login and user_email, or user_phone and user_email, or all together,
  //    but at least one optional field must be valid)
  //  - user_password of an existing user
  //  - service_id of an existing service with an existing signup for the user
  //  - likely to contain info about session: browser, os, ip
  // Returns:
  //  - access token, which is used to access protected resources
  //  - refresh token, which is used to refresh the access one, because it has small TTL
  //  0 if you've successfully logged in;
  //  3 if arguments are not valid;
  //  5 if signup not found (you've not been signed up yet);
  //  6 if user has already been logged in on this devce in this browser (no need to log in);
  //  13 if an internal error occurred
  rpc Login(LoginRequest) returns (Tokens);

  // Relogin
  //  sends new updated access token (if it's expired) by refresh token (which describes session)
  // Takes:
  //  - token, which is refresh one. You own one via Login rpc
  // Returns:
  //  - new access token, which is used to access protected resources
  //  0 if you've successfully got new access token;
  //  3 if refresh token cannot be treated as a JWT (you've sent rubbish);
  //  13 if an internal error occurred;
  //  16 if refresh token has expired (need to ask user to log in again)
  rpc Relogin(RefreshToken) returns (AccessToken);

  // Check
  //  checks if your access token still be valid and unexpired
  // Takes:
  //  - token, which is access one. You own it via Login or Relogin rpc
  // Returns:
  //  0 if access token still be valid and unexpired;
  //  3 if access token cannot be treated as a JWT (you've sent rubbish);
  //  13 if an internal error occurred
  //  16 if access token is invalid or has expired (need to call Relogin rpc)
  rpc Check(AccessToken) returns (google.protobuf.Empty);

  // Logout
  //  terminate current session, which is stored in refresh token
  // Takes:
  //  - token, which is refresh one. You own one via Login rpc
  // Returns:
  //  0 if you've succeessfully logged out (terminated the session);
  //  3 if refresh token cannot be treated as a JWT (you've sent rubbish);
  //  13 if an internal error occurred;
  //  16 if refresh token has either expired or session has already been terminated (check note 1)
  // Notes:
  //  - you must not use that refresh token again;
  //    If you do, the SSO will terminate ALL currently active sessions
  //    (you'll have to log in again from all devices);
  //    To avoid this problem, get rid of the refresh token completely after you've logged out
  rpc Logout(RefreshToken) returns (google.protobuf.Empty);

  // Protected RPCs

  // GetSessions
  //  list all user's sessions in the current service
  // Takes:
  //  - access token. You own it via Login or Relogin rpc
  //  - type of sessions, you wanna get:
  //    ALL - both terminated and active
  //    ACTIVE - active only
  //    Terminated - terminated only
  // Returns:
  //  - array of sessions. Each element contains:
  //    browser, os and ip, which the session has been opened from
  //    terminated_at - null if active, timestamp if terminated
  //  0 if you've got the sessions;
  //  3 if either type or access token is invalid;
  //  13 if an internal error occurred;
  //  16 if access token has expired (need to call Relogin rpc)
  rpc GetSessions(GetSessionsRequest) returns (Sessions);

  // GetProfile
  //  returns user data such as their login, email and phone
  // Takes:
  //  - access token. You own it via Login or Relogin rpc
  // Returns:
  //  - id of the user
  //  - login (nickname) of the user
  //  - email of the user or null
  //  - phone of the user or null
  rpc GetProfile(AccessToken) returns (UserProfile);
  
  // Dangerous RPCs
  
  // LogoutEverywhere
  //  terminates all user's active sessions
  // Takes:
  //  - either login or email or phone, which identifies user's account
  //  - password of the account
  //  - refresh token (you must be logged in to log out everywhere)
  // Returns:
  //  0 if you've successfully logged out everywhere;
  //  3 if refresh token has invalid signature;
  //  5 if user's credentials are invalid;
  //  7 if user in credentials and user opened the session mismatch
  //    (client probably has entered wrong password or
  //    forgot which account is currently in use);
  //  13 if an internal error occurred;
  //  16 if refresh token has either expired or session has already been terminated (check note 2)
  // Notes:
  //  - this rpc is dangerous
  //  - SSO will terminate ALL currently active sessions if 16 is returned
  //    (you'll have to log in again from all devices);
  //    To avoid this problem, get rid of the refresh token completely after you've logged out
  rpc LogoutEverywhere(DangerousServiceRequest) returns (google.protobuf.Empty);
  
  
  // ClearTerminatedSessions
  //  clears (completely deletes) all terminated sessions, that has ever been
  // Takes:
  //  - either login or email or phone, which identifies user's account
  //  - password of the account
  //  - refresh token (you must be logged in to clear terminated sessions)
  // Returns:
  //  0 if you've successfully got rid of terminated sessions;
  //  3 if refresh token has invalid signature;
  //  5 if user's credentials are invalid;
  //  7 if user in credentials and user opened the session mismatch
  //    (client probably has entered wrong password or
  //    forgot which account is currently in use);
  //  13 if an internal error occurred;
  //  16 if refresh token has either expired or session has already been terminated (check note 2)
  // Notes:
  //  - this rpc is dangerous
  //  - SSO will terminate ALL currently active sessions if 16 is returned
  //    (you'll have to log in again from all devices);
  //    To avoid this problem, get rid of the refresh token completely after you've logged out
  rpc ClearTerminatedSessions(DangerousServiceRequest) returns (google.protobuf.Empty);

  // Signout
  //  unlinks your registered (existing) account from the current service
  //  it's like locally delete your account (not everywhere).
  //  You have a half of year to recover the account before it will be deleted completely
  //  signed up to it
  // Takes:
  //  - either login or email or phone, which identifies user's account
  //  - password of the account
  //  - refresh token (you must be logged in to sign out)
  // Returns:
  //  0 if you've successfully signed out;
  //  3 if refresh token has invalid signature;
  //  5 if user's credentials are invalid;
  //  7 if user in credentials and user opened the session mismatch
  //    (client probably has entered wrong password or
  //    forgot which account is currently in use);
  //  13 if an internal error occurred;
  //  16 if refresh token has either expired or session has already been terminated (check note 2)
  // Notes:
  //  - this rpc is dangerous
  //  - SSO will terminate ALL currently active sessions if 16 is returned
  //    (you'll have to log in again from all devices);
  //    To avoid this problem, get rid of the refresh token completely after you've logged out
  rpc Signout(DangerousServiceRequest) returns (google.protobuf.Empty);
  
  // SignoutEverywhere
  //  unlinks your registered (existing) account from all services it's linked to
  // Takes:
  //  - either login or email or phone, which identifies user's account
  //  - password of the account
  // Returns:
  //  0 if you've successfully signed out everywhere;
  //  5 if user's credentials are invalid;
  //  13 if an internal error occurred;
  // Notes:
  //  - this rpc is so dangerous
  rpc SignoutEverywhere(DangerousRequest) returns (google.protobuf.Empty);
}

message UserCredentials {
  optional string login = 1;
  optional string email = 2;
  optional string phone = 3;
  string password = 4;
};

message SignupRequest {
  optional string user_login = 1;
  optional string user_email = 2;
  optional string user_phone = 3;
  string user_password = 4;
  int64 service_id = 5;
};

message LoginRequest {
  optional string user_login = 1;
  optional string user_email = 2;
  optional string user_phone = 3;
  string user_password = 4;
  int64 service_id = 5;
  optional string browser = 6;
  optional string os = 7;
  optional string ip = 8;
};

message Session {
  optional string browser = 1;
  optional string os = 2;
  optional string ip = 3;
  optional google.protobuf.Timestamp terminated_at = 4;
};

message AccessToken { string token = 1; }

message RefreshToken { string token = 1; }

message Tokens {
  string access = 1;
  string refresh = 2;
};

enum SessionType {
  ALL = 0;
  ACTIVE = 1;
  TERMINATED = 2;
};

message GetSessionsRequest {
  string access_token = 1;
  SessionType type = 2;
};

message Sessions { repeated Session sessions = 1; };

message DangerousServiceRequest {
  optional string login = 1;
  optional string email = 2;
  optional string phone = 3;
  string password = 4;
  string refresh_token = 5;
};

message DangerousRequest {
  optional string login = 1;
  optional string email = 2;
  optional string phone = 3;
  string password = 4;
};

message UserProfile {
  int64 id = 1;
  string login = 2;
  optional string email = 3;
  optional string phone = 4;
};